# -*- coding: utf-8 -*-
"""BARONIO_PythonCode_PCPExam.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EkJ_GLz2uP4WO3xFQvNhMRCFv_gf_NTG

# Env Config
"""

"""
================================================================================
WAREHOUSE AND ORDER MANAGEMENT SYSTEM - LogiServe S.r.l.
================================================================================

Command-line application for managing:
- Customer order registration and monitoring
- Stock level and inventory management
- Order fulfillment with automatic stock updates
- Alerts for products below reorder threshold
- Daily report generation/export
- Warehouse data and order import/export
- Logging system for operation traceability

ARCHITECTURE:
------------
The system is structured with the following classes:
- Product: management of a single item (code, stock, reorder point)
- Customer: customer profile with order history
- Order: order management with statuses (new/fulfilled/partial/on hold)
- Warehouse: full inventory with product operations
- OrderManager: order and customer management
- Report: daily report generation

REQUIREMENTS:
----------
- Python 3.7+
- Standard libraries: json, csv, datetime, logging, ast

================================================================================
"""

import json
import os
from datetime import datetime, timedelta
import csv
import ast
import logging

# Optional: download a CSV file with orders to import later from the command line

data = """ORD001,ROSSI,2024-06-01,"{'P001': 80, 'P002': 80}"
ORD002,ROSSI,2024-06-02,"{'P003': 15}"
ORD003,VERDI,2024-06-01,"{'P001': 80, 'P002': 80}"
ORD004,ROSSI,2024-06-02,"{'P003': 15}"
ORD005,VERDI,2024-06-01,"{'P001': 80, 'P002': 80}"
ORD006,ROSSI,2024-06-02,"{'P003': 15}"
ORD007,VERDI,2024-06-01,"{'P001': 80, 'P002': 80}"
ORD008,ROSSI,2024-06-02,"{'P003': 15}"
ORD009,VERDI,2024-06-01,"{'P001': 80, 'P002': 80}"
ORD010,ROSSI,2024-06-02,"{'P003': 15}"
ORD011,VERDI,2024-06-01,"{'P001': 80, 'P002': 80}"
ORD012,ROSSI,2024-06-02,"{'P003': 15}"
"""

with open('orders.csv', mode="w", newline="", encoding="utf-8") as csvfile:
    writer = csv.writer(csvfile)

    for line in data.strip().split("\n"):
        row = next(csv.reader([line]))
        writer.writerow(row)

print(f"File '{'orders.csv'}' created successfully.")

# This function is called at the start of main to populate the product catalog and customer registry.

def setup_environment(logger):

    # Populate the customer dictionary
    customers = {
        'ROSSI' : Customer('ROSSI', 'Mario Rossi', 'Rossi SRL', 'rossi@mail.com', '+39 02020202', address="Via XXX"),
        'VERDI' : Customer('VERDI', 'Luigi Verdi', 'Verdi SPA', 'verdi@mail.com', '+39 03030303', address="Via XXX"),
        'GIALLI' : Customer('GIALLI', 'Wario Gialli', 'Gialli SRLS', 'gialliwario@hotmail.it', '+39 90909090', address='Via YYY'),
        'VIOLA' : Customer('VIOLA', 'Waluigi Viola', 'Waluigi SNC', 'waluigi@mail.com', '+39 04040404', address="Via XXX")}

    # Initialize the Order Manager, Warehouse, Report, and logger
    order_manager = OrderManager(customers=customers)
    warehouse = Warehouse()
    report = Report()
    logger.info("Order manager, warehouse, and report initialized")

    # Populate the warehouse
    p001 = Product('P001', 'Faucet', 'Plumbing', 200, 20, 'pcs')
    p002 = Product('P002', 'Pipe', 'Plumbing', 300, 30, 'pcs')
    p003 = Product('P003', 'Hammer', 'Tools', 500, 20, 'pcs')
    p004 = Product('P004', 'WD-40', 'Liquids', 1000, 100, 'lt')
    p005 = Product('P005', 'Small Tube', 'Plumbing', 4000, 200, 'mt')
    p006 = Product('P006', 'CNG Fiorino', 'Vehicles', 10, 2, 'pcs')
    p007 = Product('P007', 'Shower Tray', 'Plumbing', 100, 20, 'pcs')

    warehouse.add_product(p001)
    warehouse.add_product(p002)
    warehouse.add_product(p003)
    warehouse.add_product(p004)
    warehouse.add_product(p005)
    warehouse.add_product(p006)
    warehouse.add_product(p007)

    return order_manager, warehouse, report, customers

"""# Classes

## Class Product
"""

class Product:

    def __init__(self, code, name, category, stock, reorder_point, unit_of_measure):
        self.code = code
        self.name = name
        self.category = category
        self.stock = stock
        self.reorder_point = reorder_point
        self.unit_of_measure = unit_of_measure

    def update_stock(self, quantity):
        '''
        self.stock : current product stock in the warehouse
        quantity : quantity to add to / remove from the warehouse

        This function updates the stock based on warehouse movements.
        '''
        quantity = int(quantity)
        new_stock = self.stock + quantity
        if new_stock < 0:
            raise ValueError("Stock cannot become negative.")
        self.stock = new_stock

    def __str__(self):
        '''
        Text representation of the product.
        '''
        return (f"Code: {self.code} - Name: {self.name} "
                f"(Category: {self.category}) - Stock: {self.stock}/{self.reorder_point} {self.unit_of_measure}")

    def needs_reorder(self):
        '''
        Returns a bool indicating whether the product needs to be reordered.
        '''
        return self.stock < self.reorder_point

    def check_availability(self, requested_quantity):
        '''
        requested_quantity : int - quantity to be withdrawn

        Return:
        bool - True if there is sufficient stock, False otherwise
        '''
        return self.stock >= requested_quantity  # >= not > (if I ask for 10 and have 10, that's fine!)

# Example
# switch = Product(code="SW001", name="Switch", category="Electrical", stock=100, reorder_point=20, unit_of_measure="pcs")

"""## Class Customer"""

class Customer:

    def __init__(self, customer_id, name, company_name, email, phone, address=""):
        '''
        Initializes a new customer.

        Parameters:
        customer_id: str - unique customer identifier
        name: str - contact person's name
        company_name: str - customer company name
        email: str - contact email
        phone: str - phone number
        address: str - address (optional)
        '''
        self.customer_id = customer_id
        self.name = name
        self.company_name = company_name
        self.email = email
        self.phone = phone
        self.address = address
        self.order_history = []  # List of order_id

    def add_order(self, order_id):
        '''
        Adds an order to the customer's history.

        Parameters:
        order_id: str - ID of the order to add
        '''
        self.order_history.append(order_id)

    def __str__(self):
        '''
        Text representation of the customer.
        '''
        return (f"Customer #{self.customer_id} - {self.company_name} "
                f"(Ref: {self.name}) - Email: {self.email} - "
                f"Total orders: {len(self.order_history)}")

# Usage example:
# ROSSI = Customer(
#     customer_id="CLI001",
#     name="Mario Rossi",
#     company_name="Elettro Rossi S.r.l.",
#     email="m.rossi@elettrorossi.it",
#     phone="+39 02 1234567"
# )

"""## Class Order"""

class Order:

    def __init__(self, order_id, customer, date, products, priority="normal"):
        self.order_id = order_id
        self.customer = customer  # reference to a Customer object
        self.date = date
        self.priority = priority
        self.products = products
        self.status = "new"

    def __str__(self):
        '''
        Formatted order print.
        '''
        return (f"Order #{self.order_id} - Customer: {self.customer.company_name} - "
                f"Date: {self.date} - Status: {self.status} - "
                f"Products: {self.products}")

    def change_status(self, new_status):
        '''
        Changes the order status.

        Parameters:
        new_status = str - can be 'new', 'fulfilled', 'partial', 'on hold'
        '''
        valid_statuses = ('new', 'fulfilled', 'partial', 'on hold')
        assert new_status in valid_statuses, f"Status not allowed: {new_status}"
        self.status = new_status

    def change_quantity(self, product_code, new_quantity):
        '''
        Changes the quantity of a product in the order.
        If the product exists, updates the quantity.
        If the quantity is zero or negative, removes the product.
        If the product does not exist, adds it if the quantity is positive.
        '''
        if product_code in self.products:
            if new_quantity > 0:
                self.products[product_code] = new_quantity
            else:
                # Remove the product if the quantity is not positive
                self.products.pop(product_code)
        else:
            if new_quantity > 0:
                self.products[product_code] = new_quantity
            else:
                raise ValueError("Invalid quantity for adding a new product.")

    def edit_order(self):
        product_code = input("Enter the product code to modify: ")
        if product_code in self.products:
            try:
                new_quantity = int(input(f"Product {product_code} found, enter new quantity: "))
                self.change_quantity(product_code, new_quantity)
            except ValueError as e:
                print(f"Error: {e}")
        else:
            response = input(f"Product {product_code} not found. Do you want to add it? [y/N]")
            if response.lower() == "y":
                try:
                    new_quantity = int(input("Enter the quantity to add: "))
                    self.change_quantity(product_code, new_quantity)
                    print(f"Product {product_code} added with quantity {new_quantity}")
                except ValueError as e:
                    print(f"Error: {e}")
            else:
                print(f"No changes made")

# Example
# ROSSI = Customer(customer_id="CLI001", name="Mario Rossi", company_name="Elettro Rossi S.r.l.",
#                    email="m.rossi@elettrorossi.it", phone="+39 02 1234567")
# order1 = Order(order_id="001", customer=ROSSI, date="2024-06-01", products={'t-shirts': 10})
# print(order1)

"""## Class Warehouse"""

class Warehouse:

    def __init__(self):
        self.products = {}  # Empty dictionary: {code: Product_object}

    def add_product(self, product):
        '''
        Adds a new product to the warehouse.
        product: object of type Product
        '''
        if product.code in self.products:
            raise ValueError(f"Product {product.code} already exists in the warehouse.")
        self.products[product.code] = product

    def find_product_by_id(self, code):
        '''
        Finds and returns a product given its code.
        return: Product object or None if it does not exist
        '''
        product = self.products.get(code)
        if product is None:
            raise ValueError(f"Product with code '{code}' not found in the warehouse.")
        return product

    def find_products_by_category(self, category):
        '''
        Finds and returns products by category.
        return: Product object or None if it does not exist
        '''
        results = []
        for product in self.products.values():
            if product.category == category:
                results.append(str(product))
        if len(results) == 0:
            raise ValueError(f"Product with category '{category}' not found in the warehouse.")
        return results

    def find_products_by_stock(self, threshold):
        '''
        Finds and returns products with stock less than or equal to the threshold.
        return: list of Product objects (can be empty if no results found)
        '''
        results = []
        for product in self.products.values():
            if product.stock <= threshold:
                results.append(str(product))
        if len(results) == 0:
            raise ValueError(f"No product with stock below {threshold} found in the warehouse.")
        return results

    def view_inventory(self):
        '''
        Creates a dictionary with all products and their stock levels.
        '''
        inventory = []
        for code, product in self.products.items():
            inventory.append({
                'code': code,
                'name': product.name,
                'stock': product.stock,
                'unit_of_measure': product.unit_of_measure
            })
        return inventory

    def products_to_reorder(self):
        '''
        Returns a list of dictionaries with products whose stock is below the reorder point.
        '''
        to_reorder = []
        for product in self.products.values():
            if product.needs_reorder():
                to_reorder.append({
                    'code': product.code,
                    'name': product.name,
                    'stock': product.stock,
                    'reorder_point': product.reorder_point
                })
        return to_reorder

    def export_inventory_json(self, file_name):
        inventory = self.view_inventory()
        with open(file_name, 'w', encoding='utf-8') as f:
            json.dump(inventory, f, indent=2)
        return file_name

    def import_inventory_json(self, file_name):
        with open(file_name, 'r', encoding='utf-8') as f:
            inventory = json.load(f)

        for item in inventory:
            code = item['code']
            # Check if the product already exists in the warehouse
            if code in self.products:
                product = self.products[code]
                # Update essential properties
                product.name = item.get('name', product.name)
                product.stock = item.get('stock', product.stock)
                product.reorder_point = item.get('reorder_point', product.reorder_point)
                product.unit_of_measure = item.get('unit_of_measure', product.unit_of_measure)
            else:
                # Create a new product if it does not exist
                new_product = Product(
                    code=code,
                    name=item['name'],
                    category=item.get('category', ''),
                    stock=item.get('stock', 0),
                    reorder_point=item.get('reorder_point', 0),
                    unit_of_measure=item.get('unit_of_measure', '')
                )
                self.add_product(new_product)

        # True to indicate the import was completed successfully
        return True

    def print_inventory(self):
        '''
        Prints the inventory in a readable format.
        '''
        for product in self.products.values():
            below_threshold = product.stock < product.reorder_point
            flag = " *" if below_threshold else ""
            print(f"Code: {product.code} - Product: {product.name} - Stock: {product.stock}/{product.reorder_point} {product.unit_of_measure}{flag}")

    def print_products_to_reorder(self):
        '''
        Prints products with stock below the established reorder point in a readable format.
        '''
        result = ""
        for product in self.products.values():
            if product.needs_reorder():
                result += (f"{product.code}: {product.name} - Stock {product.stock}/{product.reorder_point}\n")

        if result == "":
            return "No products to reorder"
        else:
            print(result)

"""## Class OrderManager"""

class OrderManager:

    def __init__(self, customers=None):
        self.customers = customers if customers is not None else {}
        self.orders = {}  # {order_id : Order_object}

    def view_orders(self):
        '''
        Prints all orders.
        '''
        listing = []
        for order in self.orders.values():
            listing.append(f"Order {order.order_id} - Customer: {order.customer.company_name} - Order date: {order.date} - Status: {order.status}")
        return listing

    def register_order(self, order):
        '''
        Adds a new order to the manager.

        Parameters:
        order: object of type Order
        '''
        self.orders[order.order_id] = order

    def check_date(self):
        '''
        Checks that the date is in the correct format.
        '''
        while True:
            date_input = input("Enter the order date (format YYYY-MM-DD): ")
            try:
                datetime.strptime(date_input, "%Y-%m-%d")
                return date_input
            except ValueError:
                print("Invalid date. Make sure to enter the date in the correct format (YYYY-MM-DD).")

    def register_customer_from_input(self):
        '''
        Registers a new customer based on data entered by the user.

        Return: object of type Customer
        '''
        while True:
            customer_id = input("Enter the unique customer ID: ")
            if customer_id in self.customers:
                print(f"Error: a customer with ID '{customer_id}' already exists.")
            else:
                break  # UNIQUE ID

        name = input("Enter the customer name: ")
        company_name = input("Enter the customer company name: ")
        email = input("Enter the customer email: ")
        phone = input("Enter the customer phone number: ")
        address = input("Enter the customer address (optional): ")
        customer = Customer(customer_id, name, company_name, email, phone, address)
        self.customers[customer.customer_id] = customer

        return customer

    def create_and_register_order_from_input(self, customer_id_str):
        '''
        Creates a new order based on data entered by the user.

        Parameters:
        customer_id_str: str - ID of the customer to associate with the order

        Return: object of type Order
        '''
        if customer_id_str in self.customers:
            customer = self.customers[customer_id_str]

            order_id = input("Enter the order ID: ")
            date = self.check_date()
            products = {}

            while True:
                product_code = input("Enter the product code: ")
                while True:
                    quantity_input = input("Enter the quantity: ")
                    try:
                        quantity = int(quantity_input)
                        break
                    except ValueError:
                        print("Invalid quantity. Make sure to enter a whole number.")

                products[product_code] = quantity

                continue_input = input("Do you want to add more products? [y/N]")
                if continue_input.lower() != 'y':
                    break

            order = Order(order_id, customer, date, products)
            self.register_order(order)

        else:
            print(f"Customer with ID '{customer_id_str}' not found.")
            menu_input1 = input("Proceed with customer registration? [y/N]")
            if menu_input1.lower() == 'y':
                customer = self.register_customer_from_input()
                self.customers[customer.customer_id] = customer
                order_id = input("Enter the order ID: ")
                date = input("Enter the order date (format YYYY-MM-DD): ")
                products = {}
                while True:
                    product_code = input("Enter the product code: ")
                    quantity = int(input("Enter the quantity: "))
                    products[product_code] = quantity
                    continue_input = input("Do you want to add more products? [y/N]")
                    if continue_input.lower() != 'y':
                        break
                order = Order(order_id, customer, date, products)
                self.register_order(order)
            else:
                print("Customer registration cancelled.")
                return None

        return order

    def import_orders_csv(self, file_name):
        '''
        Imports orders from a CSV file.

        Parameters:
        file_name (str): name of the CSV file to import.

        Return: list of Order objects
        '''
        registered_orders = []  # to keep track of imported orders

        with open(file_name, 'r', encoding='utf-8') as f:
            reader = csv.reader(f, delimiter=',')

            for line_num, line in enumerate(reader, start=1):
                try:
                    order_id, customer_id, date, products_str = line
                    products = ast.literal_eval(products_str)
                except ValueError as e:
                    print(f"Error parsing row {line_num}: {e}")
                    continue

                customer = self.customers.get(customer_id)
                if customer is None:
                    print(f"Customer with ID '{customer_id}' not found in row {line_num}. Order skipped.")
                    continue

                order = Order(order_id, customer, date, products)

                self.register_order(order)
                customer.add_order(order_id)
                registered_orders.append(order)

        return registered_orders

    def find_order(self, order_id):
        '''
        Finds the order and returns the order ID.
        Return: Order object or None
        '''
        return self.orders.get(order_id)

    def orders_by_status(self, status):
        '''
        Returns a list of orders with a given status.
        status: 'new', 'fulfilled', 'partial', 'on hold'
        Return: list of Order objects
        '''
        orders = []
        for order in self.orders.values():
            if order.status == status:
                orders.append(order)
        return orders

    def fulfill_order(self, order_id, warehouse):
        '''
        Fulfills an order by updating the warehouse stock.
        If the stock is insufficient, fulfills the available quantity.

        Parameters:
        order_id: str - ID of the order to fulfill
        warehouse: Warehouse object

        Return: string with outcome
        '''
        messages = []
        # STEP 1: Find the order
        order = self.find_order(order_id)
        if order is None:
            raise ValueError('Order not found.')

        # STEP 2: Initialize counters
        fully_fulfilled_products = 0
        partially_fulfilled_products = 0
        unfulfilled_products = 0
        total_products = len(order.products)

        # STEP 3: Iterate over the order's products
        fulfilled_products = {}

        for product_code, quantity in order.products.items():
            # Find the product in the warehouse
            try:
                # Check availability
                if quantity <= 0:
                    raise ValueError(f'Invalid quantity ({quantity} for product {product_code})')

                product = warehouse.find_product_by_id(product_code)

                # Determine quantity to fulfill
                if product.stock >= quantity:
                    # FULL FULFILLMENT
                    fulfilled_quantity = quantity
                    product.update_stock(-fulfilled_quantity)
                    fully_fulfilled_products += 1
                    messages.append(f'Fulfilled {fulfilled_quantity} x {product_code}')

                elif product.stock > 0:
                    # PARTIAL FULFILLMENT
                    fulfilled_quantity = product.stock
                    product.update_stock(-fulfilled_quantity)
                    partially_fulfilled_products += 1
                    messages.append(f'Partially fulfilled {fulfilled_quantity} x {product_code}')

                elif product.stock == 0:
                    # NOT AVAILABLE
                    fulfilled_quantity = 0
                    unfulfilled_products += 1
                    messages.append(f'Not fulfilled {fulfilled_quantity} x {product_code}')

                # Track fulfilled quantity
                fulfilled_products[product_code] = fulfilled_quantity

            except ValueError as e:
                messages.append(f"Error in order {order_id}, product {product_code}: {e}")
                continue

        # STEP 4: Determine final status
        if fully_fulfilled_products == total_products:
            order.change_status("fulfilled")
            outcome = "FULLY FULFILLED"
        elif fully_fulfilled_products + partially_fulfilled_products > 0:
            order.change_status("partial")
            outcome = "PARTIALLY FULFILLED"
        else:
            order.change_status("on hold")
            outcome = "NOT FULFILLED"

        # STEP 5: Return result
        messages.append(f"Order {order.order_id}: {outcome}\n - Products fulfilled: {fulfilled_products}/{total_products}")
        return messages

    def export_orders_json(self):
        '''
        Exports all orders to a JSON file.

        Return: name of the JSON file
        '''
        orders = []
        for order in self.orders.values():
            orders.append({
                'order_id': order.order_id,
                'customer': order.customer.customer_id,
                'date': order.date,
                'products': order.products,
                'status': order.status
            })

        with open(f"order_registry_{datetime.now().date()}.json", 'w', encoding='utf-8') as f:
            json.dump(orders, f, indent=2)

        return f"order_registry_{datetime.now().date()}.json"

    def import_orders_json(self, file_name):
        '''
        Imports orders from a JSON file.

        Parameters:
        file_name (str): name of the JSON file to import.

        Return: list of Order objects
        '''
        with open(file_name, 'r', encoding='utf-8') as f:
            orders = json.load(f)
        for order_data in orders:
            order_id = order_data['order_id']
            customer_id = order_data['customer']
            customer = self.customers.get(customer_id)
            if customer is None:
                print(f"Customer with ID '{customer_id}' not found. Order skipped.")
                continue
            date = order_data['date']
            products = order_data['products']
            status = order_data['status']
            order = Order(order_id, customer, date, products, status)
            self.register_order(order)
            customer.add_order(order_id)

        return orders

"""## Class Report"""

class Report:
    def __init__(self, date=None):
        '''
        Initializes the report with a date.

        date (str): date in yymmdd10 format. If None, uses today's date.
        date = datetime.today().strftime('%Y-%m-%d')
        '''
        if date is None:
            self.date = datetime.today().strftime('%Y-%m-%d')
        else:
            self.date = date

    def calculate_orders(self, order_manager):
        '''
        Calculates the number of new, active and partial orders.

        Parameters:
        order_manager (OrderManager): object that manages orders

        Return:
        dict: new, active and partial orders.
        '''
        status_count = {'new': 0,
                        'fulfilled': 0,
                        'partial': 0,
                        'on hold': 0}

        for order in order_manager.orders.values():
            if order.status in status_count:
                status_count[order.status] += 1

        return status_count

    def calculate_best_selling_products(self, order_manager):
        '''
        Calculates the ranking of best-selling products.

        Parameters:
        order_manager (OrderManager): object that manages orders.

        Return:
        dict: products and quantities sold.
        '''
        sales = {}
        for order in order_manager.orders.values():
            if order.status in ['fulfilled', 'partial']:
                for code, quantity in order.products.items():
                    sales[code] = sales.get(code, 0) + quantity

        return sales

    def calculate_warehouse_status(self, warehouse):
        '''
        Calculates the current warehouse status, e.g. products in catalog,
        products below reorder threshold, etc.

        Parameters:
        warehouse (Warehouse): object representing the warehouse.

        Return:
        dict: statistics on the warehouse status.
        '''
        total_products = len(warehouse.products)
        below_reorder = sum(1 for p in warehouse.products.values() if p.needs_reorder())

        return {
            'total_products': total_products,
            'products_below_reorder': below_reorder
        }

    def products_below_reorder(self, warehouse):
        '''
        Returns the list of products that need to be reordered.

        Parameters:
        warehouse (Warehouse): object representing the warehouse.

        Return:
        list: products to reorder.
        '''
        reorder_products = [p['code'] for p in warehouse.products_to_reorder()]
        return reorder_products

    def calculate_stock_variation(self, order_manager):
        '''
        Calculates the stock variation compared to the previous day.

        Parameters:
        order_manager (OrderManager): object representing the warehouse.

        Return:
        dict: stock variations.
        '''
        variation = {}
        filtered_statuses = ['fulfilled', 'partial']
        for order in order_manager.orders.values():
            if order.status in filtered_statuses:
                for product, quantity in order.products.items():
                    variation[product] = variation.get(product, 0) + quantity

        return variation

    def generate_report(self, order_manager, warehouse):
        '''
        Generates the full report as a formatted string.

        Parameters:
        order_manager (OrderManager): object that manages orders.
        warehouse (Warehouse): object representing the warehouse.

        Return:
        str: report text.
        '''
        report_lines = []

        # Header
        report_lines.append("="*59)
        report_lines.append("-"*20 + f" REPORT {self.date} " + "-"*20)
        report_lines.append("="*59)
        report_lines.append("\n")

        # 1. Order summary by status

        report_lines.append('1. ORDER SUMMARY BY STATUS\n')
        for order_type, number in self.calculate_orders(order_manager).items():
            report_lines.append(f'Orders with status "{order_type}": {number}')

        report_lines.append("\n" + "-"*59 + "\n")

        # 2. Best-selling products

        report_lines.append('2. BEST-SELLING PRODUCTS (sorted in descending order)\n')

        sales = self.calculate_best_selling_products(order_manager)
        if sales:
            # Descending sort
            sorted_products = sorted(sales.items(), key=lambda x: x[1], reverse=True)
            top_5_products = sorted_products[:5]

            for product, n_sales in top_5_products:
                report_lines.append(f"Product {product}: {n_sales} sales")
        else:
            report_lines.append('No products purchased.')

        report_lines.append("\n" + "-"*59 + "\n")

        # 3. Warehouse status

        report_lines.append(f'3. WAREHOUSE STATUS\n')
        status = self.calculate_warehouse_status(warehouse)
        n_total = status['total_products']
        n_reorder = status['products_below_reorder']
        report_lines.append(f'Total number of products in warehouse: {n_total}')
        report_lines.append(f'Number of products on reorder: {n_reorder}')

        report_lines.append("\n" + "-"*59 + "\n")

        # 4. Products below reorder threshold

        report_lines.append(f'4. PRODUCTS BELOW REORDER THRESHOLD\n')
        warehouse_below_reorder = self.products_below_reorder(warehouse)
        if warehouse_below_reorder:
            for item in warehouse_below_reorder:
                report_lines.append(f"- {item}")
        else:
            report_lines.append('No products below reorder threshold.')

        report_lines.append("\n" + "-"*59 + "\n")

        # 5. Stock variation

        report_lines.append(f'5. STOCK VARIATION\n')
        stock_variation = self.calculate_stock_variation(order_manager).items()
        if stock_variation:
            for product, variation in stock_variation:
                unit = warehouse.find_product_by_id(product).unit_of_measure
                report_lines.append(f'Product {product}: outflow of {variation} {unit}')
        else:
            report_lines.append('No stock variation.')

        report_lines.append("\n")

        report_lines.append("="*59)
        report_lines.append("-"*23 + f" END OF REPORT " + "-"*23)
        report_lines.append("="*59)

        return '\n'.join(report_lines)

    def export_report_txt(self, order_manager, warehouse, file_name=None):
        '''
        Exports the report to a text file.

        Parameters:
        order_manager (OrderManager): object that manages orders.
        warehouse (Warehouse): object representing the warehouse.
        file_name (str, optional): name of the output file. If None, uses a standard name.

        Return:
        str: name of the created file, or None if an error occurred.
        '''
        try:
            report = self.generate_report(order_manager, warehouse)
            if file_name is None:
                file_name = f'report_{self.date}.txt'

            with open(file_name, 'w', encoding='utf-8') as f:
                f.write(report)

            return file_name

        except Exception as e:
            print(f'Error during report export: {e}')
            return None

"""# MAIN (\_\_main\_\_)"""

# Menu function definitions
def menu():
    print("\nChoose an operation:")
    print("1. Register new orders")
    print("2. View or fulfill orders")
    print("3. Warehouse lookup")
    print("4. Report creation")
    print("5. Save DB to JSON")
    print("0. Exit")
    choice = input("Enter the operation number: ")
    return choice

def menu_1():
    print("\nChoose an operation:")
    print("1. Register new order (manual)")
    print("2. Register new order (csv)")
    choice_1 = input("Enter the operation number: ")
    return choice_1

def menu_2():
    print("\nChoose an operation:")
    print("1. View orders")
    print("2. Fulfill order")
    choice_2 = input("Enter the operation number: ")
    return choice_2

def menu_3():
    print("\nChoose an operation:")
    print("1. View warehouse status")
    print("2. Modify product stock")
    print("3. Search products")
    choice_3 = input("Enter the operation number: ")
    return choice_3

def menu_3_3():
    print("\nChoose an operation:")
    print("1. Search product by code")
    print("2. Search product by category")
    print("3. Search product by stock level")
    choice_3_3 = input("Enter the operation number: ")
    return choice_3_3

def menu_5():
    print("\nChoose an operation:")
    print("1. Export warehouse to JSON")
    print("2. Import warehouse from JSON")
    print("3. Export order list to JSON")
    print("4. Import order list from JSON")

    choice_5 = input("Enter the operation number: ")

    return choice_5

# Logger definition
def configure_logger():
    '''
    Configures the logger to record operations to a file.
    '''
    logger = logging.getLogger('WarehouseApp_Logiserve')
    logger.setLevel(logging.INFO)

    file_handler = logging.FileHandler('app.log', encoding='utf-8')
    file_handler.setLevel(logging.INFO)

    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)

    logger.addHandler(file_handler)
    return logger

# Below-threshold check function definition
def check_order_below_threshold(order, warehouse):
    '''
    Checks if the order contains products below the reorder threshold.
    '''
    critical_products = []
    for product_code in order.products.keys():
        try:
            product = warehouse.find_product_by_id(product_code)
            if product.needs_reorder():
                critical_products.append((product_code, product.stock, product.reorder_point))
        except ValueError:
            pass
    return critical_products

def show_below_threshold_alert(critical_products):
    '''
    Shows an alert to the user for products below threshold.
    '''
    if critical_products:
        print("\n" + "="*60)
        print("--- PRODUCTS BELOW REORDER THRESHOLD ---")
        print("="*60)
        for code, stock, threshold in critical_products:
            print(f"  â€¢ Product: {code} - Stock: {stock}/{threshold}")
        print("="*60 + "\n")

# ==============================================================================
# MAIN
# ==============================================================================

def main():
    # Configure the logger
    logger = configure_logger()
    logger.info("=" * 60)
    logger.info("APPLICATION STARTED")
    logger.info("=" * 60)

    # Setup environment
    order_manager, warehouse, report, customers = setup_environment(logger)

    while True:
        choice = menu()

        # 1. ORDER ENTRY
        if choice == '1':
            choice_1 = menu_1()

            # 1.1 MANUAL ORDER ENTRY
            if choice_1 == '1':
                customer = input("Enter the Customer ID: ")
                logger.info(f"Manual order registration for customer: {customer}")
                order = order_manager.create_and_register_order_from_input(customer)
                if order:
                    logger.info(f"Order registered: {order.order_id}")
                    critical_products = check_order_below_threshold(order, warehouse)
                    if critical_products:
                        show_below_threshold_alert(critical_products)
                        logger.warning(f"Order {order.order_id} contains {len(critical_products)} product(s) below threshold")
                else:
                    logger.warning(f"Order registration cancelled for customer: {customer}")

            # 1.2 ORDER IMPORT FROM CSV
            elif choice_1 == '2':
                order_file = input('Enter the path to the .csv file: ')
                logger.info(f"Importing orders from CSV: {order_file}")
                try:
                    imported_orders = order_manager.import_orders_csv(order_file)
                    print(f"File imported successfully. {len(imported_orders)} orders registered.")
                    logger.info(f"Import completed: {len(imported_orders)} orders imported")
                    for order in imported_orders:
                        critical_products = check_order_below_threshold(order, warehouse)
                        if critical_products:
                            logger.warning(f"Order {order.order_id} from CSV contains {len(critical_products)} product(s) below threshold")
                    order_manager.view_orders()
                except FileNotFoundError:
                    print(f"File not found: {order_file}")
                    logger.error(f"CSV file not found: {order_file}")
                except Exception as e:
                    print(f"Error during import: {e}")
                    logger.error(f"Error during CSV import: {e}")

            else:
                print("Invalid choice, please try again.")

        # 2. VIEW OR FULFILL ORDERS
        elif choice == '2':
            choice_2 = menu_2()

            # 2.1 VIEW ORDER LIST
            if choice_2 == '1':
                print("\n---- View orders ----")
                orders = order_manager.view_orders()
                logger.info(f"Order view requested: {len(orders)} total orders")
                for order_str in orders:
                    print(order_str)

            # 2.2 FULFILL ORDERS
            elif choice_2 == '2':
                order_id = input("Enter the ID of the order to fulfill: ")
                logger.info(f"Order fulfillment requested: {order_id}")
                try:
                    messages = order_manager.fulfill_order(order_id, warehouse)
                    for message in messages:
                        print(message)
                    logger.info(f"Order {order_id} fulfilled successfully")
                except Exception as e:
                    print(f"Error while fulfilling order {order_id}: {e}.")
                    logger.error(f"Error fulfilling order {order_id}: {e}")

            else:
                print("Invalid choice, please try again.")

        # 3. WAREHOUSE STATUS
        elif choice == '3':
            choice_3 = menu_3()

            # 3.1 PRINT WAREHOUSE STATUS
            if choice_3 == '1':
                print('')
                print('---- Print warehouse status ----')
                logger.info("Warehouse status view requested")
                warehouse.print_inventory()
                print('')

            # 3.2 MODIFY WAREHOUSE STOCK
            elif choice_3 == '2':
                # Case where the warehouse is empty
                if warehouse.products == {}:
                    print("The warehouse is empty.")
                    logger.info("Stock modification attempt: warehouse empty")
                    continue
                product_code = input("Enter the product code to update: (e.g. PRO001) ")
                logger.info(f"Stock modification requested for product: {product_code}")
                try:
                    try:
                        product = warehouse.find_product_by_id(product_code)
                    except ValueError as e:
                        print(f"Error: {e}")
                        logger.warning(f"Product not found: {product_code}")
                        continue
                    quantity = int(input(f"Enter the quantity to add (use a negative number to subtract): "))
                    product.update_stock(quantity)
                    print(f"Stock updated: {product.stock} {product.unit_of_measure}")
                    logger.info(f"Stock for {product_code} updated by {quantity} units. New stock: {product.stock}")
                except ValueError as e:
                    print(f"Error: {e}")
                    logger.error(f"Error modifying stock for {product_code}: {e}")

            # 3.3 SEARCH PRODUCT
            elif choice_3 == '3':
                print('---- Product search ----')
                search_key = menu_3_3()

                # 3.3.1 SEARCH PRODUCT BY CODE
                if search_key == "1":
                    product_code = input('Enter the product code: ')
                    logger.info(f"Search by code '{product_code}'")
                    try:
                        product = warehouse.find_product_by_id(product_code)
                        print(product)
                        logger.info(f"Search by code '{product_code}': product found")
                    except ValueError as e:
                        print(f"Error: {e}")
                        logger.info(f"Search by code '{product_code}': product not found")

                # 3.3.2 SEARCH PRODUCT BY CATEGORY
                elif search_key == "2":
                    product_category = input("Enter the product category: ")
                    logger.info(f"Search for products by category: {product_category}")
                    try:
                        product = warehouse.find_products_by_category(product_category)
                        print("\n".join(product))
                        logger.info(f"Search by category '{product_category}': {len(product)} product(s) found")
                    except ValueError as e:
                        print(f"Error: {e}")
                        logger.info(f"Search by category '{product_category}': no results")

                # 3.3.3 SEARCH PRODUCT BY THRESHOLD
                elif search_key == "3":
                    reorder_threshold = int(input("Enter the reorder threshold: "))
                    logger.info(f"Search for products with stock <= {reorder_threshold}")
                    product = warehouse.find_products_by_stock(reorder_threshold)
                    if product:
                        print("\n".join(product))
                        logger.info(f"Stock search: {len(product)} product(s) below threshold {reorder_threshold}")
                    else:
                        print(f"No products found with stock below {reorder_threshold}")
                        logger.info(f"Stock search {reorder_threshold}: no results")
                else:
                    print("Invalid choice, please try again.")

        # 4. CREATE OR PRINT REPORT
        elif choice == '4':
            logger.info("Report generation requested")
            report_content = report.generate_report(order_manager, warehouse)
            print("\n" + report_content)

            # 4.1 EXPORT REPORT
            export_choice = input("Do you want to export the report? [y/n]: ")
            if export_choice.lower() == 'y':
                file_name = report.export_report_txt(order_manager, warehouse, file_name=f"report_{datetime.now().date()}.txt")
                print(f"Report saved in 'report_{datetime.now().date()}.txt'.")
                logger.info(f"Report exported to file: {file_name}")
            else:
                logger.info("Report export cancelled")
                continue

        # 5. EXPORT / IMPORT DB IN JSON FORMAT
        elif choice == '5':
            choice_5 = menu_5()

            # 5.1 EXPORT WAREHOUSE TO JSON FORMAT
            if choice_5 == '1':
                print('Creating warehouse in json format...')
                json_file_name = f'inventory_{datetime.now().date()}.json'
                warehouse.export_inventory_json(file_name=json_file_name)
                print('Report saved successfully.')
                logger.info(f"Inventory exported to JSON: {json_file_name}")

            # 5.2 IMPORT INVENTORY FROM JSON
            elif choice_5 == '2':
                print('Importing warehouse from json...')
                json_file_name = input('Enter the path to the .json file: ')
                try:
                    warehouse.import_inventory_json(file_name=json_file_name)
                    print('Report imported successfully.')
                    logger.info(f"Inventory imported from JSON: {json_file_name}")
                except FileNotFoundError:
                    print(f"File not found: {json_file_name}")
                    logger.error(f"JSON file not found for import: {json_file_name}")
                except Exception as e:
                    print(f"Error during import: {e}")
                    logger.error(f"Error during JSON import: {e}")

            # 5.3 EXPORT ORDER LIST TO JSON FORMAT
            elif choice_5 == '3':
                print('Exporting order list to json format...')
                json_file_name = order_manager.export_orders_json()
                print(f'Report {json_file_name} saved successfully.')
                logger.info(f"Orders exported to JSON {json_file_name}")

            # 5.4 IMPORT ORDER LIST FROM JSON
            elif choice_5 == '4':
                print('Importing order list from json...')
                json_file_name = input('Enter the path to the .json file: ')
                try:
                    order_manager.import_orders_json(file_name=json_file_name)
                    print("Import completed successfully.")
                    logger.info(f"Orders imported successfully.")
                except FileNotFoundError:
                    print(f"File not found: {json_file_name}")
                    logger.error(f'JSON file not found for import: {json_file_name}')
                else:
                    print(f"Error during import: {e}")
                    logger.error(f"Error during import: {e}")

            else:
                print("Invalid choice, please try again.")

        # 0. EXIT
        elif choice == '0':
            print("Exiting.")
            logger.info("Application closed")
            logger.info("=" * 60)
            break

        else:
            print("Invalid choice, please try again.")
            logger.warning(f"Invalid main menu choice: {choice}")

main()

"""
================================================================================
USAGE INSTRUCTIONS
================================================================================

STARTING THE PROGRAM:
-------------------
1. Run the command: python warehouse_management.py
2. The system automatically initializes:
   - 4 sample customers (ROSSI, VERDI, GIALLI, VIOLA)
   - 7 sample products (P001-P007)
   - Logging system (app.log)

MAIN MENU:
---------------
1. Register new orders
   1.1 Manual: interactive entry with availability check
   1.2 From CSV: bulk import from file (see format below)

2. View or fulfill orders
   2.1 View: complete order list with status
   2.2 Fulfill: process order and update stock

3. Warehouse lookup
   3.1 View full inventory
   3.2 Manually modify stock
   3.3 Search products (by code/category/stock level)

4. Report creation
   Generates daily report
   - Option to export as TXT

5. Save DB to JSON
   5.1 Export warehouse status to JSON
   5.2 Import warehouse status from JSON
   5.3 Export order list to JSON
   5.4 Import order list from JSON

0. Exit

SAMPLE ORDER FORMAT:
ORD001,ROSSI,2024-06-01,"{'P001': 10, 'P002': 5}"

Notes:
- customer_id must exist in the system, otherwise a new customer profile will be requested
- Date format: YYYY-MM-DD

USAGE EXAMPLES:
-------------
1. Register an order manually:
   Menu 1 -> 1 -> enter required data

2. Register an order from CSV:
   Menu 1 -> 2 -> enter file path (e.g.: sample_orders.csv)

3. View orders:
   Menu 2 -> 1 (complete order list)

4. Fulfill an order:
   Menu 2 -> 2 -> enter order ID

5. Check warehouse products:
   Menu 3 -> 1 (products marked with * need reordering)

6. Generate report:
   Menu 4 -> y (to save)

7. Export warehouse to JSON:
   Menu 5 -> 1 (creates json file)

================================================================================"""